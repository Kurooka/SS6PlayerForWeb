<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv=”Pragma” content=”no-cache”>
  <meta http-equiv=”Cache-Control” content=”no-cache”>
  <title>SpriteStudio6 Web Player</title>
  <!-- pixi.jsの読込 -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/4.8.5/pixi.min.js"></script>
  <!-- flatbuffers関連 -->
  <script src="https://cdn.jsdelivr.net/npm/flatbuffers@1.10.2/js/flatbuffers.js"></script>
  <!-- ssfblib -->
  <script src="./ssfblib.umd.js"></script>
  <!-- ss6player -->
  <script src="../../packages/ss6player-pixi/dist/ss6player-pixi.umd.js"></script>
  <script src="./ss6player-controller.js"></script>

  <link rel="stylesheet" href="./rich-index.css">

</head>
<body>


  <script>
    let playerController = null;

    let pixiApplication = null;
    let ss6Project = null;
    let ss6Player = null;
    const ssfbFilePath = "./MeshBone/Knight.ssbp.ssfb";
    // const ssfbFilePath ="../../../TestData/character_sample1/character_sample1.ssbp.ssfb";
    
    let playerElement;
    let previewElement;
    let animationSelectAreaElement;
    let zoomAreaElement;

    let playControlAreaElement;
    let playSwitchButtonElement;
    let frameNumberElement;
    let endFrameNumberElement;
    let seekBarElement;
    let fpsElement;


    let currentSsaeName = null;
    let currentAnimationName = null;

    // 前回ズームしたときのタイムスタンプ
    let lastPreviewZoomTimeStamp = null;

    function loadAnimation(ssaeName, animationName) {
      currentSsaeName = ssaeName;
      currentAnimationName = animationName;
      playerController.setupAnimation(currentSsaeName, currentAnimationName);

      const selectedAnimations = playerElement.querySelectorAll('.animation.selected');
      for(let selectedAnimation of selectedAnimations){
        selectedAnimation.classList.remove('selected');
      }
      const currentAnimation = playerElement.querySelector('.animation[data-animation-pack-name="' + currentSsaeName + '"][data-name="' + currentAnimationName + '"]')
      currentAnimation.classList.add('selected');
    }

      
    function refreshPlaySwitch() {
      const isPlaying = playerController.ss6Player.isPlaying;
      const isPausing = playerController.ss6Player.isPausing;

      if(isPlaying){
        if(isPausing){
          playSwitchButtonElement.classList.remove('paused');

        }else{
          playSwitchButtonElement.classList.add('paused');

        }
        
      }else{
        playSwitchButtonElement.classList.remove('paused');

      }

    }


    window.onload = function(){
      // const ssaeName = 'Knight_bomb';
      // const animeName = 'Balloon';

      playerElement = document.querySelector('.player');
      previewElement = playerElement.querySelector('.preview');
      animationSelectAreaElement = playerElement.querySelector('.animation-select-area');
      zoomAreaElement = playerElement.querySelector('.zoom-area');

      playControlAreaElement = playerElement.querySelector('.play-control-area');
      playSwitchButtonElement = playerElement.querySelector('.play-switch-area .button-area');
      frameNumberElement = playControlAreaElement.querySelector('.frame-number');
      endFrameNumberElement = playControlAreaElement.querySelector('.end-frame-number');
      seekBarElement = playControlAreaElement.querySelector('.seek-bar');
      fpsElement = playerElement.querySelector('.fps');



      playerController = new SS6PlayerController(ssfbFilePath);
      playerController.onComplete = () => {
        const animePackMap = playerController.animePackMap;
        for(let animePackName in animePackMap){
          const animePackElement = document.createElement('div');
          const animePackData = animePackMap[animePackName];

          // アニメーションパック名のラベルの追加
          const animePackLabelAreaElement = document.createElement('div');
          animePackLabelAreaElement.classList.add('label-area');

          // 折りたたみアイコンの追加
          const animePackExtendIconElement = document.createElement('span');
          animePackExtendIconElement.classList.add('extend-icon');
          animePackExtendIconElement.textContent = "▲";
          animePackLabelAreaElement.appendChild(animePackExtendIconElement);

          // アイコンの追加
          const animePackIconElement = document.createElement('img');
          animePackIconElement.classList.add('icon');
          animePackIconElement.src = './images/animation_pack.png';
          animePackLabelAreaElement.appendChild(animePackIconElement);

          // ラベルの追加
          const animePackLabelElement = document.createElement('label');
          animePackLabelElement.textContent = animePackName;
          animePackLabelAreaElement.appendChild(animePackLabelElement);


          animePackLabelAreaElement.addEventListener('click', (event) => {
            const animePackLabelAreaElement = event.currentTarget;
            const animePackElement = animePackLabelAreaElement.closest('.animation-pack');
            animePackElement.classList.toggle('extend');
          });

          animePackElement.appendChild(animePackLabelAreaElement);

          animePackElement.setAttribute('data-name', animePackName);
          const partsCount = animePackData['parts_count'];
          animePackElement.setAttribute('data-parts-count', partsCount);
          animePackElement.title = "パーツ数: " + partsCount;

          animePackElement.classList.add('animation-pack');
          // animePackElement.classList.add('extend');

          const animationAreaElement = document.createElement('div');
          animationAreaElement.classList.add('animation-area');
          const animationMap = animePackData['animations'];
          for (let animationName in animationMap) {
            const animationElement = document.createElement('div');

            // アニメーション名のラベルの追加
            const animationLabelAreaElement = document.createElement('div');
            animationLabelAreaElement.classList.add('label-area');

            // アイコンの追加
            const animationIconElement = document.createElement('img');
            animationIconElement.classList.add('icon');
            animationIconElement.src = './images/animation.png';
            animationLabelAreaElement.appendChild(animationIconElement);
            
            // ラベルの追加
            // animationLabelElement.textContent = animationName;
            const animationLabelElement = document.createElement('label');
            animationLabelElement.textContent = animationName;
            animationLabelAreaElement.appendChild(animationLabelElement);

            animationElement.appendChild(animationLabelAreaElement);

            animationElement.setAttribute('data-animation-pack-name', animePackName);
            animationElement.setAttribute('data-name', animationName);

            animationElement.classList.add('animation');
            animationElement.addEventListener('click', (event) => {
              const animationElement = event.currentTarget;
              const ssaeName = animationElement.getAttribute('data-animation-pack-name');
              const animationName = animationElement.getAttribute('data-name');
              loadAnimation(ssaeName, animationName);
            });

            animationAreaElement.appendChild(animationElement);
            
          }
          animePackElement.appendChild(animationAreaElement);

          animationSelectAreaElement.appendChild(animePackElement);

        }

        

      };
      playerController.onUpdate = (player) => {
        frameNumberElement.innerText = player.currentCachedFrameNumber;
        seekBarElement.value = player.currentCachedFrameNumber;

      };
      playerController.onPlayStateChangeCallback = (isPlaying, isPausing) => {
        console.log('onPlayStateChangeCallback');
        if(isPlaying){
          seekBarElement.min = playerController.ss6Player.startFrame;
          seekBarElement.max = playerController.ss6Player.endFrame;
          endFrameNumberElement.innerText = playerController.ss6Player.endFrame;
          fpsElement.innerText = playerController.ss6Player.fps;

        }else{

        }

        refreshPlaySwitch();

      };
      playerController.load(previewElement);

      // 再生ボタン
      playSwitchButtonElement.addEventListener('click', (event) => {
        if(playerController.ss6Player.isPausing){
          playerController.resume();
        }else if(playerController.ss6Player.isPlaying) {
          playerController.pause();
        }else{
          playerController.play();
        }
      });
      previewElement.addEventListener('keydown', (event) => {
        // console.log('keydown', event);
        if (event.code === "Space") {
          // スペースキーを押された場合、再生ボタンをクリックさせる
          if (!event.repeat) {
            // 初回の Key入力のみ
            playSwitchButtonElement.click();
          }
        } else if (event.code === "ArrowRight") {
          playerController.pause();
          playerController.nextFrame();
        } else if (event.code === "ArrowLeft") {
          playerController.pause();
          playerController.prevFrame();
        }
      });

      
      // アニメーションスピード
      const animationSpeedSelectElement = playerElement.querySelector('.animation-speed');
      animationSpeedSelectElement.addEventListener('change', (event)=>{
        const selectElement = event.currentTarget;
        const value = selectElement.value;
        playerController.ss6Player.SetAnimationSpeed(value);
      });

      // プレビューの背景色設定
      const backgroundColorPickerElement = playerElement.querySelector('.background-color');
      backgroundColorPickerElement.addEventListener('change', (event)=>{
        const element = event.currentTarget;
        const value = element.value;
        // console.log('color', value);
        previewElement.style.backgroundColor = value;

      });

      // グリッド表示
      const gridCheckElement = playerElement.querySelector('.display-grid');
      gridCheckElement.addEventListener('change', (event)=>{
        const element = event.currentTarget;
        const checked = element.checked;
        // console.log('checked', checked);
        playerController.isDisplayGrid = checked;
        playerController.switchGridDisplay();

      });

      // ループのON/OFF
      const loopCheckElement = playerElement.querySelector('.loop');
      loopCheckElement.addEventListener('change', (event) => {
        const element = event.currentTarget;
        const checked = element.checked;
        console.log('checked', checked);
        playerController.switchLoop(checked);

      });


      // SeekBar変更
      seekBarElement.addEventListener('input', (event)=> {
        const rangeElement = event.currentTarget;
        const value = rangeElement.valueAsNumber;
        playerController.pause();

        frameNumberElement.innerText = value;
        playerController.setFrame(value);
      }, false);

      // ズームイン
      const zoomInElement = zoomAreaElement.querySelector('.zoom-in');
      zoomInElement.addEventListener('click', (event) => {
        playerController.zoomIn();
      });
      
      // ズームアウト
      const zoomOutElement = zoomAreaElement.querySelector('.zoom-out');
      zoomOutElement.addEventListener('click', (event) => {
        playerController.zoomOut();
      });
      
      previewElement.addEventListener('mousedown', (event) => {
        // console.log('mousedown');
      });
      previewElement.addEventListener('mousemove', (event)=>{
        if(event.buttons === 1){
          // 左クリック時のみ
          const targetElement = event.target;
          if (event.target.tagName === 'CANVAS') {
            // キャンバス自体をドラッグ時のみ
            const movementX = event.movementX;
            const movementY = event.movementY;
            // console.log('movementX', movementX);
            // console.log('movementY', movementY);

            playerController.movePosition(movementX, movementY);

          }
        }
      });

      previewElement.addEventListener('mousewheel', (event) => {
        // console.log('mousewheel', event);
        event.preventDefault();

        const timeStamp = event.timeStamp;
        if(this.lastPreviewZoomTimeStamp !== null){
          if((timeStamp - this.lastPreviewZoomTimeStamp) < 100) {
            return;
          }
        }
        this.lastPreviewZoomTimeStamp = timeStamp;
        const deltaY = event.deltaY;
        if(deltaY > 0){
          playerController.zoomIn();
        }else if(deltaY < -0){
          playerController.zoomOut();
        }
      });

    };

  </script>


  <div class="player">
    <div class="animation-select-area">

    </div>

    <div class="preview" tabIndex=0>
      <div class="head-bar-area">
        <label>グリッド</label>
        <input type="checkbox" class="display-grid" />
        <label>ループ</label>
        <input type="checkbox" class="loop" checked/>
        <label>背景色</label>
        <input type="color" class="background-color" value="#ffffff" />
        <label>再生速度:</label>
        <select class="animation-speed">
          <option value=0.5>x0.5</option>
          <option value=1 selected>x1</option>
          <option value=2>x2</option>
          <option value=3>x3</option>
        </select>
        <label>FPS:</label><span class="fps"></span>

      </div>
      <div class="play-switch-area">
        <div class="button-area">
          <div class="play-switch-sign"></div>
        </div>
      </div>

      <div class="zoom-area">
        <img class="zoom-in zoom-control" title="ズームイン" src="./images/zoom_in.png" />
        <img class="zoom-out zoom-control" title="ズームアウト" src="./images/zoom_out.png" />
      </div>


      <div class="play-control-area">
        <div class="contents">
          
          <input type="range" class="seek-bar" value="0">
          <div class="frame-area">
            <span class="frame-number"></span>
            /
            <span class="end-frame-number"></span>

          </div>

        </div>
      
      
      </div>
    </div>
  </div>

</body>
</html>
